#include <string>
#include <cassert>
#include <algorithm>
#include <queue>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <map>
#include <deque>
#include <climits>
#include <set>
#include <vector>
#include <functional>
#include <stack>
#include <unordered_set>
#include <unordered_map>
#include <list>
using namespace std;
#define REP(i,n) for(int i=0;i<(n);i++)
#define REP1(i,a,b) for(int i=(a);i<=(b);i++)
#define ALL(x) (x).begin(),(x).end()
#define FOR(i, c) for(auto &i: c)
#define PER(i,n) for(int i=(n)-1;i>=0;i--)
#define PER1(i,a,b) for(int i=(a);i>=(b);i--)
#define MP make_pair
#define PB push_back
#define MS0(x) memset(x,0,sizeof(x))
#define MS1(x) memset(x,-1,sizeof(x))
#define V(T) vector<T >
#define EB emplace_back
#define MAX(x, a) x = max(x, a)
#define MIN(x, a) x = min(x, a)

typedef long long LL;
typedef vector<int> VI;
typedef pair<int, int> PII;
// #line 40 "TreeWalker.cpp"
#include <string>
#include <vector>
class TreeWalker {
public:
    int calc(int N, int A0, int B, int C, int MOD) {
        
    }
};
// BEGIN CUT HERE
/*
// PROBLEM STATEMENT
// Given a directed graph G, we will use p(G) to denote the number of ordered pairs of distinct vertices (x,y) such that G contains a directed path from x to y.

For example, let G1 be a graph on vertices {0,1,2} that contains the edges 0->1 and 1->2.
For this graph we have p(G1)=3: there is a path from 0 to 1, a path from 1 to 2, and a path from 0 to 2.
Similarly, let G2 contain the edges 0->1 and 2->1.
Then p(G2)=2: the only two valid paths are from 0 to 1 and from 2 to 1.

You are given an undirected tree T with N vertices.
The vertices are numbered 0 through N-1.
The exact format in which T is given is specified below.

We can change T into a directed graph U by replacing each undirected edge of T by one of the two possible directed edges.
As there are exactly N-1 edges in T, there are exactly 2^(N-1) possible graphs U we can produce.

For each possible U compute the value p(U).
Let X be the sum of those 2^(N-1) values.
Compute and return the value (X modulo 1,000,000,007).

You are given the ints N, A0, B, C, and MOD.
Use the pseudocode given below to generate the tree T.
Watch out for integer overflow.

A[0] = A0
for i = 1 .. N-2:
	A[i] = (B * A[i-1] + C) % MOD

for i = 1 .. N-1:
	j = A[i-1] % i
	add an edge between vertices i and j 


DEFINITION
Class:TreeWalker
Method:calc
Parameters:int, int, int, int, int
Returns:int
Method signature:int calc(int N, int A0, int B, int C, int MOD)


CONSTRAINTS
-N will be between 2 and 100,000, inclusive.
-A0, B and C will be between 0 and 1,000,000,000, inclusive.
-MOD will be between 1 and 1,000,000,000, inclusive.


EXAMPLES

0)
4
0
1
1
1000

Returns: 34

The graph T generated by our pseudocode is the path 0 - 1 - 2 - 3.
There are 2^3 = 8 possible ways to assign directions to these edges:

In two cases (0 -> 1 -> 2 -> 3, 0 <- 1 <- 2 <- 3) we have p(U) = 6.
In four cases (0 -> 1 -> 2 <- 3, 0 -> 1 <- 2 <- 3, 0 <- 1 -> 2 -> 3, 0 <- 1 <- 2 -> 3) we have p(U) = 4.
In two cases (0 -> 1 <- 2 -> 3, 0 <- 1 -> 2 <- 3) we have p(U) = 3.

The sum of p(U) over all possible U is X = 6+6+4+4+4+4+3+3 = 34.

1)
10
0
0
0
1

Returns: 13824



2)
16
15
1
1
16

Returns: 917506



3)
1000
385498676
349131547
115776323
614879544

Returns: 245566366



4)
100000
111222333
444555666
777888999
123456789

Returns: 119729770



*/
#include <ctime>
#include <cmath>
#include <string>
#include <vector>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;

int main(int argc, char* argv[])
{
	if (argc == 1) 
	{
		cout << "Testing TreeWalker (500.0 points)" << endl << endl;
		for (int i = 0; i < 20; i++)
		{
			ostringstream s; s << argv[0] << " " << i;
			int exitCode = system(s.str().c_str());
			if (exitCode)
				cout << "#" << i << ": Runtime Error" << endl;
		}
		int T = time(NULL)-1462324531;
		double PT = T/60.0, TT = 75.0;
		cout.setf(ios::fixed,ios::floatfield);
		cout.precision(2);
		cout << endl;
		cout << "Time  : " << T/60 << " minutes " << T%60 << " secs" << endl;
		cout << "Score : " << 500.0*(.3+(.7*TT*TT)/(10.0*PT*PT+TT*TT)) << " points" << endl;
	}
	else
	{
		int _tc; istringstream(argv[1]) >> _tc;
		TreeWalker _obj;
		int _expected, _received;
		time_t _start = clock();
		switch (_tc)
		{
			case 0:
			{
				int N = 4;
				int A0 = 0;
				int B = 1;
				int C = 1;
				int MOD = 1000;
				_expected = 34;
				_received = _obj.calc(N, A0, B, C, MOD); break;
			}
			case 1:
			{
				int N = 10;
				int A0 = 0;
				int B = 0;
				int C = 0;
				int MOD = 1;
				_expected = 13824;
				_received = _obj.calc(N, A0, B, C, MOD); break;
			}
			case 2:
			{
				int N = 16;
				int A0 = 15;
				int B = 1;
				int C = 1;
				int MOD = 16;
				_expected = 917506;
				_received = _obj.calc(N, A0, B, C, MOD); break;
			}
			case 3:
			{
				int N = 1000;
				int A0 = 385498676;
				int B = 349131547;
				int C = 115776323;
				int MOD = 614879544;
				_expected = 245566366;
				_received = _obj.calc(N, A0, B, C, MOD); break;
			}
			case 4:
			{
				int N = 100000;
				int A0 = 111222333;
				int B = 444555666;
				int C = 777888999;
				int MOD = 123456789;
				_expected = 119729770;
				_received = _obj.calc(N, A0, B, C, MOD); break;
			}
			/*case 5:
			{
				int N = ;
				int A0 = ;
				int B = ;
				int C = ;
				int MOD = ;
				_expected = ;
				_received = _obj.calc(N, A0, B, C, MOD); break;
			}*/
			/*case 6:
			{
				int N = ;
				int A0 = ;
				int B = ;
				int C = ;
				int MOD = ;
				_expected = ;
				_received = _obj.calc(N, A0, B, C, MOD); break;
			}*/
			/*case 7:
			{
				int N = ;
				int A0 = ;
				int B = ;
				int C = ;
				int MOD = ;
				_expected = ;
				_received = _obj.calc(N, A0, B, C, MOD); break;
			}*/
			default: return 0;
		}
		cout.setf(ios::fixed,ios::floatfield);
		cout.precision(2);
		double _elapsed = (double)(clock()-_start)/CLOCKS_PER_SEC;
		if (_received == _expected)
			cout << "#" << _tc << ": Passed (" << _elapsed << " secs)" << endl;
		else
		{
			cout << "#" << _tc << ": Failed (" << _elapsed << " secs)" << endl;
			cout << "           Expected: " << _expected << endl;
			cout << "           Received: " << _received << endl;
		}
	}
}

// END CUT HERE
